<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tun Blog</title>
    <description>山本无忧，因雪白头；水本无愁，因风起皱；我本无忧，应该欢喜</description>
    <link>http://localhost:4000/tuyuwang.github.io/</link>
    <atom:link href="http://localhost:4000/tuyuwang.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 02 Apr 2018 13:34:34 +0800</pubDate>
    <lastBuildDate>Mon, 02 Apr 2018 13:34:34 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>Swift面包</title>
        <description>&lt;p&gt;1、&lt;a href=&quot;https://github.com/Ramotion/expanding-collection&quot;&gt;expanding-collection&lt;/a&gt;源码摘录&lt;/p&gt;

&lt;p&gt;使用枚举值的rawValue来表示图片名称&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum Asset: String {

    case backgroundImage = &quot;BackgroundImage&quot;
    case closeButton = &quot;CloseButton&quot;
    case dots
    case face1
    case face2
    case heand
    case icons
    case image
    case item0
    case item1
    case item2
    case item3
    case locationButton
    case map
    case pinIcon
    case searchIcon
    case stars
    case title = &quot;Title&quot;

    //为枚举值添加计算属性，方便获取image
    var image: Image {
        let bundle = Bundle(for: BundleToken.self)
        #if os(iOS) || os(tvOS) || os(watchOS)
            let image = Image(named: rawValue, in: bundle, compatibleWith: nil)
        #elseif os(OSX)
            let image = bundle.image(forResource: rawValue)
        #endif
        guard let result = image else { fatalError(&quot;Unable to load image \(rawValue).&quot;) }
        return result
    }
}

//调用
let image = Asset.backgroundImage.image
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;拓展: 实现字符串获取图片的另一种方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension String {
    var toImage: UIImage? {
        return UIImage(named: self)
    }
}

//调用
let image = &quot;backgroundImage&quot;.toImage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;typealias的妙用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  typealias ItemInfo = (imageName: String, title: String)
  fileprivate let items: [ItemInfo] = [(&quot;item0&quot;, &quot;Boston&quot;), (&quot;item1&quot;, &quot;New York&quot;), (&quot;item2&quot;, &quot;San Francisco&quot;), (&quot;item3&quot;, &quot;Washington&quot;)]

//调用(类似于类调用属性的形式)
  let info = items[index]
  cell.backgroundImageView?.image = UIImage(named: info.imageName)
  cell.customTitle.text = info.title
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;范型初始化工具，特点：简洁明了，为实例设置属性时不用写实例名称，只用$0就行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;internal func Init&amp;lt;Type&amp;gt;(_ value: Type, block: (_ object: Type) -&amp;gt; Void) -&amp;gt; Type {
    block(value)
    return value
}

//调用
let upGesture = Init(UISwipeGestureRecognizer(target: self, action: #selector(DemoViewController.swipeHandler(_:)))) {
    $0.direction = .up
}
  view.addGestureRecognizer(upGesture)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;遍历所有的子视图，并传给外界&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
protocol SubviewsForEach {
    func subviewsForEach(_ f: (UIView) -&amp;gt; Void)
}

extension SubviewsForEach where Self: UIView {

    func subviewsForEach(_ f: (UIView) -&amp;gt; Void) {
        forEachView(self, f: f)
    }

    fileprivate func forEachView(_ view: UIView, f: (UIView) -&amp;gt; Void) {
        view.subviews.forEach {
            f($0)

            if $0.subviews.count &amp;gt; 0 {
                forEachView($0, f: f)
            }
        }
    }
}

extension UIView: SubviewsForEach {}

//调用
copyView.frontContainerView.subviewsForEach { 
    if $0.tag == Constants.HideKey { 
        $0.alpha = 0 
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、Kinfisher源码摘录&lt;/p&gt;

&lt;p&gt;3、SwiftyJSON源码摘录&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/tuyuwang.github.io/2018/01/16/Swift%E9%9D%A2%E5%8C%85/</link>
        <guid isPermaLink="true">http://localhost:4000/tuyuwang.github.io/2018/01/16/Swift%E9%9D%A2%E5%8C%85/</guid>
        
        <category>iOS</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>iOS RSA加签</title>
        <description>&lt;p&gt;先贴最终解决方案: &lt;a href=&quot;https://github.com/TuYuWang/iOSSignAndVerify&quot;&gt;SignAndVerify byTun&lt;/a&gt; 支持SHA1、SHA384、SHA256、SHA224、SHA512对摘要数据进行加签。&lt;/p&gt;

&lt;p&gt;故事开端: 服务端人员给我一个私钥字符串(没有头部和尾部字符串)，我需要用私钥对摘要数据进行加签后再发送给服务端进行公钥验签。&lt;/p&gt;

&lt;p&gt;踩坑:服务端生成的私钥字符串是PKCS8格式的，而我们需要的是PKCS1格式的私钥字符串。可以通过字符串长度判断是哪种格式的。&lt;a href=&quot;http://www.5ixuexiwang.com/str/length.php&quot;&gt;在线字符串长度计算&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;PKCS#1对应的私钥字符串长度为824(按1024取模)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;openssl genrsa -out private_key.pem 1024
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PKCS#8对应的私钥字符串长度为861。&lt;/p&gt;

&lt;p&gt;也可以通过以下方法判断私钥的格式:&lt;/p&gt;

&lt;p&gt;PKCS:美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准&lt;/p&gt;

&lt;p&gt;PKCS#1:定义RSA公开密钥算法加密和签名机制，主要用于组织PKCS#7中所描述的数字签名和数字信封。&lt;/p&gt;

&lt;p&gt;PKCS#8：描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等.&lt;/p&gt;

&lt;p&gt;RSA Public Key file (PKCS#1)
The RSA Public key PEM file is specific for RSA keys.
It starts and ends with the tags:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN RSA PUBLIC KEY-----
BASE64 ENCODED DATA
-----END RSA PUBLIC KEY-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RSA Private Key file (PKCS#1)
The RSA private key PEM file is specific for RSA keys.
It starts and ends with the tags:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN RSA PRIVATE KEY-----
BASE64 ENCODED DATA
-----END RSA PRIVATE KEY-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Public Key file (PKCS#8)
Because RSA is not used exclusively inside X509 and SSL/TLS, a more generic key format is available in the form of PKCS#8, that identifies the type of public key and contains the relevant data.
It starts and ends with the tags:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN PUBLIC KEY-----
BASE64 ENCODED DATA
-----END PUBLIC KEY-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Private Key file (PKCS#8)
Because RSA is not used exclusively inside X509 and SSL/TLS, a more generic key format is available in the form of PKCS#8, that identifies the type of private key and contains the relevant data.
The unencrypted PKCS#8 encoded data starts and ends with the tags:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN PRIVATE KEY-----
BASE64 ENCODED DATA
-----END PRIVATE KEY-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;明白了问题出在哪，现在就来说说解决方案：&lt;/p&gt;

&lt;p&gt;1、简单粗暴点就是让后台给你PKCS1格式的私钥字符串。&lt;a href=&quot;http://blog.csdn.net/u010725842/article/details/50614030&quot;&gt;java转openssl的RSA算法公私钥&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、自己转换(PKCS#8-&amp;gt;PKCS#1)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;openssl pkcs8 -in pkcs8.pem -nocrypt -out pri_key.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3、用openssl生成iOS／Java使用的公私钥&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//生成模长为1024bit的私钥文件private_key.pem
openssl genrsa -out private_key.pem 1024

//生成证书请求文件rsaCertReq.csr.(这一步会提示输入国家、省份、mail等信息，可以根据实际情况填写，或者全部不用填写，直接全部敲回车.)
openssl req -new -key private_key.pem -out rsaCerReq.csr

//生成证书rsaCert.crt，并设置有效时间为10年
openssl x509 -req -days 3650 -in rsaCerReq.csr -signkey private_key.pem -out rsaCert.crt

//生成供iOS使用的公钥文件public_key.der
openssl x509 -outform der -in rsaCert.crt -out public_key.der

//生成供iOS使用的私钥文件private_key.p12.(这一步会提示给私钥文件设置密码，直接输入想要设置密码即可，然后敲回车，然后再验证刚才设置的密码，再次输入密码，然后敲回车，完毕！)
openssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt

//生成供Java使用的公钥rsa_public_key.pem
openssl rsa -in private_key.pem -out rsa_public_key.pem -pubout

//生成供Java使用的私钥pkcs8_private_key.pem
openssl pkcs8 -topk8 -in private_key.pem -out pkcs8_private_key.pem -nocrypt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nice!有了正确的私钥后，接下来就是加签了，使用文件路径读取私钥的请看这里&lt;a href=&quot;http://blog.csdn.net/zhangmengleiblog/article/details/51362761&quot;&gt;任意门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里我使用的是这个框架&lt;a href=&quot;https://github.com/yubin-X/iOSSignAndVerify&quot;&gt;SignAndVerify&lt;/a&gt;,这个框架默认是通过私钥字符串用SHA1算法加签，而服务端是需要用SHA384算法进行加签，所以就fork一下，然后进行拓展&lt;a href=&quot;https://github.com/TuYuWang/iOSSignAndVerify&quot;&gt;SignAndVerify byTun&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;基本概念&quot;&gt;基本概念：&lt;/h4&gt;

&lt;p&gt;数字签名：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;只有信息的发送者才能产生的别人无法伪造的一段数字串，对信息发送者发送信息真实性的有效证明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要，然后用私钥对摘要进行加密，将加密后的摘要作为数字签名和报文一起发送给接收方。接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公钥对报文附加的数字签名进行解密，如果这两个摘要相同，那么接收方就能确认该数字签名是发送方的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;作用: 1、能确定消息确实是由发送方签名并发出来的。2、数字签名能确定消息的完整性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;哈希函数(哈希算法):将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。它是一种单向密码体制,即它是一个从明文到密文的不可逆的映射,只有加密过程,没有解密过程。&lt;/p&gt;

&lt;p&gt;RSA算法:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1977年由Ron Rivest、Adi Shamirh和LenAdleman发明的，RSA就是取自他们三个人的名字。算法基于一个数论：将两个大素数相乘非常容易，但要对这个乘积的结果进行因式分解却非常困难，因此可以把乘积公开作为公钥。该算法能够抵抗目前已知的所有密码攻击。RSA算法是一种非对称算法，算法需要一对密钥，使用其中一个加密，需要使用另外一个才能解密。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;作用: 1、用私钥在客户端加签，然后公钥在服务器用公钥验签。防抵赖，防止别人模拟我们的客户端来攻击我们的服务器，导致瘫痪。2、用公钥加密数据，以及服务器端用私钥解密。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;iOS加解密(导入Security.framework)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SecKeyEncrypt：使用公钥对数据进行加密。&lt;/li&gt;
  &lt;li&gt;SecKeyDecrypt：使用私钥对数据进行解密。&lt;/li&gt;
  &lt;li&gt;SecKeyRawVerify：使用公钥对数字签名和数据进行验证，以确认该数据的来源合法性。&lt;/li&gt;
  &lt;li&gt;SecKeyRawSign：使用私钥对数据进行摘要并生成数字签名。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 11 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/tuyuwang.github.io/2017/12/11/RSA%E5%8A%A0%E7%AD%BE/</link>
        <guid isPermaLink="true">http://localhost:4000/tuyuwang.github.io/2017/12/11/RSA%E5%8A%A0%E7%AD%BE/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS开发小技巧</title>
        <description>&lt;h2 id=&quot;分类&quot;&gt;分类&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#tableView&quot;&gt;UITableView系列&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#textField&quot;&gt;UITextField系列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p id=&quot;tableView&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;uitableview系列&quot;&gt;UITableView系列&lt;/h3&gt;

&lt;h4 id=&quot;uitableviewcell灰线显示方案&quot;&gt;UITableViewCell灰线显示方案&lt;/h4&gt;

&lt;p&gt;思路：重写UItableViewCell， 将需要显示的子视图都添加到contenView上，并进行约束，将cell的颜色设置为白色，contentView的颜色设置为灰色，定义接口设置contentView的edges，可通过传入正数或负数控制灰线显示顶部还是底部和灰线的高度&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension UITableViewCell {
    public func setLineHeight(_ height: Int) {
        let top = max(height, 0)
        let bottom = abs(min(height, 0))
        contentView.snp.updateConstraints { (ConstraintMaker) in
            ConstraintMaker.edges.equalTo(UIEdgeInsetsMake(top, 0, bottom, 0))
        }
        layoutSubviews()
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p id=&quot;textField&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;uitextfield系列&quot;&gt;UITextField系列&lt;/h3&gt;

&lt;h4 id=&quot;调整textfield内容显示-如图&quot;&gt;调整textField内容显示, 如图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tuyuwang.github.io/img/Tips/demo-0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//重写
- (CGRect)leftViewRectForBounds:(CGRect)bounds
{
    CGRect iconRect = [super leftViewRectForBounds:bounds];
    iconRect.origin.x += 10;// 右偏10
    return iconRect;
}

- (CGRect)textRectForBounds:(CGRect)bounds
{
    CGRect iconRect = [super textRectForBounds:bounds];
    iconRect.origin.x += 10;// 右偏10
    return iconRect;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Fri, 08 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/tuyuwang.github.io/2017/09/08/Tips/</link>
        <guid isPermaLink="true">http://localhost:4000/tuyuwang.github.io/2017/09/08/Tips/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Alamofire实战记录</title>
        <description>&lt;h3 id=&quot;urlrequestconvertible-协议的使用&quot;&gt;URLRequestConvertible 协议的使用&lt;/h3&gt;

&lt;p&gt;创建一个路由枚举，调用效果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let loginRequest = EnterRouter.login(userPhone, userPassword)
        request(loginRequest).responseJSON { (respone) in
            print(JSON(respone.result.value ?? &quot;&quot;))
        }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
let baseURL = &quot;http://xxxxx&quot;
var TNParamters = [String: String]()

enum EnterRouter: URLRequestConvertible {
    
    case login(String, String)
    case regist(String, String, String)
    case logout
    
    private var httpMethod: HTTPMethod {
        return .post
    }
    
    private var method: String {
        switch self {
        case .login:
            return &quot;user.login&quot;
        case .regist:
            return &quot;user.regist&quot;
        case .logout:
            return &quot;user.logout&quot;
        }
    }
    
    private var paramters: [String: Any] {
        
        switch self {
        case .login(let userName, let password):
            TNParamters.updateValue(userName, forKey: &quot;phoneNo&quot;)
            TNParamters.updateValue(password, forKey: &quot;password&quot;)
            return baseParamters
            
        case .regist(let userName, let password, let verifyCode):
            
            TNParamters.updateValue(userName, forKey: &quot;phoneNo&quot;)
            TNParamters.updateValue(password, forKey: &quot;password&quot;)
            TNParamters.updateValue(verifyCode, forKey: &quot;verifyCode&quot;)
            return baseParamters
            
        case .logout:
            
            return baseParamters
        }
    }
    
    private var baseParamters: [String: Any] {
            TNParamters.updateValue(method, forKey: &quot;method&quot;)
            return TNParamters
    }
    
    func asURLRequest() throws -&amp;gt; URLRequest {
        
        let url = URL(string: baseURL)
        var request = URLRequest(url: url!)
        request.httpMethod = httpMethod.rawValue
        do {
            let result = try URLEncoding.default.encode(request, with: paramters)
            return result
        } catch let error {
            return request
        }
    }


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 03 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/tuyuwang.github.io/2017/09/03/Alamofire/</link>
        <guid isPermaLink="true">http://localhost:4000/tuyuwang.github.io/2017/09/03/Alamofire/</guid>
        
        <category>iOS</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Tun Blog</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Hello World, Hello Blog.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#preview&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tools&quot;&gt;工具&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#build1&quot;&gt;搭建本地博客&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#build2&quot;&gt;部署线上博客&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#resources&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p id=&quot;preview&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;

&lt;p&gt;我说：要有blog。所以就有了Tun Blog。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;tools&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;工具&quot;&gt;工具&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Jekylly&lt;/li&gt;
  &lt;li&gt;GitHub Pages&lt;/li&gt;
&lt;/ul&gt;

&lt;p id=&quot;build1&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;搭建本地博客&quot;&gt;搭建本地博客&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;安装Jeklly
    &lt;blockquote&gt;
      &lt;p&gt;gem install jekyll&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;创建blog文件
    &lt;blockquote&gt;
      &lt;p&gt;jekyll new blog&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;进入blog文件
    &lt;blockquote&gt;
      &lt;p&gt;cd blog&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;运行服务
    &lt;blockquote&gt;
      &lt;p&gt;jekyll serve&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;打开浏览器
    &lt;blockquote&gt;
      &lt;p&gt;http://localhost:4000&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;blog文件结构&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_cofig.yml  #配置全局信息
_posts      #存放博文(有一个markdown的默认博文)
_site       #存放jekyll转化生成的页面
about.md    #关于
Gemfile
Gemfile.lock
index.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;hr /&gt;
&lt;p&gt;jekyll常用命令&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build             #修改内容后使用，更新界面
jekyll serve -B          #后台运行服务
jekyll serve             #运行服务
jekyll serve --watch     #可以边修改，边刷新界面
ps aux|grep jekyllch     #查看jekyll后台运行的进程
kill -9 线程号            #关闭线程，在同一个jekyll生成的文件下，只能运行一个进程 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p id=&quot;build2&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;部署线上博客&quot;&gt;部署线上博客&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;Create a new respository, Respository name -&amp;gt; yourGithubUserName.github.io&lt;/li&gt;
  &lt;li&gt;Choose a theme on Settings&lt;/li&gt;
  &lt;li&gt;Clone this Respository&lt;/li&gt;
  &lt;li&gt;Copy the blog content file to Respository ,then commit change to github&lt;/li&gt;
  &lt;li&gt;Open the URL : https://yourGithubUserName.github.io&lt;/li&gt;
&lt;/ol&gt;

&lt;p id=&quot;resources&quot;&gt;&lt;/p&gt;

&lt;h4 id=&quot;参考资料&quot;&gt;参考资料&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekylly官网&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages文档&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io/blob/master/README.zh.md&quot;&gt;Theme by Hux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 18 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/tuyuwang.github.io/2017/05/18/%E7%94%9F%E6%B4%BB/</link>
        <guid isPermaLink="true">http://localhost:4000/tuyuwang.github.io/2017/05/18/%E7%94%9F%E6%B4%BB/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
